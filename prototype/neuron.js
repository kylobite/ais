// Generated by CoffeeScript 1.6.3
(function() {
  var Neuron, and_neuron, or_neuron, xnor_neuron, xor_neuron;

  Neuron = (function() {
    function Neuron(zs) {
      this.zs = zs;
      this.xs = null;
      this.ws = null;
      this.learning_rate = 0.1;
      this.generation = 0;
      this.neurons = null;
    }

    Neuron.prototype.load_vector = function(xs) {
      var x;
      return this.xs = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = xs.length; _i < _len; _i++) {
          x = xs[_i];
          _results.push([-1, x[0], x[1]]);
        }
        return _results;
      })();
    };

    Neuron.prototype.load_neurons = function(neurons) {
      return this.neurons = neurons;
    };

    Neuron.prototype.next_generation = function(debug) {
      var c, cache, d, error, i, n, network, neuron, ns, q, sum, w, x, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2;
      ns = new Array;
      cache = new Array;
      i = 0;
      _ref = this.xs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        ns[i] = [-1];
        n = 1;
        _ref1 = this.neurons;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          neuron = _ref1[_j];
          ns[i][n] = neuron.parse_neuron(x, i);
          n = n + 1;
        }
        i = i + 1;
      }
      if (this.ws === null) {
        this.ws = (function() {
          var _k, _ref2, _results;
          _results = [];
          for (q = _k = 0, _ref2 = ns[0].length - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; q = 0 <= _ref2 ? ++_k : --_k) {
            _results.push(0);
          }
          return _results;
        })();
      }
      i = 0;
      for (_k = 0, _len2 = ns.length; _k < _len2; _k++) {
        n = ns[_k];
        sum = 0;
        for (c = _l = 0, _ref2 = this.ws.length - 1; 0 <= _ref2 ? _l <= _ref2 : _l >= _ref2; c = 0 <= _ref2 ? ++_l : --_l) {
          sum = sum + n[c] * this.ws[c];
        }
        network = 1 / (1 + Math.pow(Math.E, sum * -1));
        if (debug) {
          cache.push(Math.round(network * 1) / 1);
        }
        error = this.zs[i] - network;
        d = error * this.learning_rate;
        i = i + 1;
        this.ws = (function() {
          var _m, _ref3, _results;
          _results = [];
          for (w = _m = 0, _ref3 = this.ws.length - 1; 0 <= _ref3 ? _m <= _ref3 : _m >= _ref3; w = 0 <= _ref3 ? ++_m : --_m) {
            _results.push(this.ws[w] = Math.round((this.ws[w] + n[w] * d) * 1000) / 1000);
          }
          return _results;
        }).call(this);
      }
      this.generation = this.generation + 1;
      if (debug) {
        console.log(cache);
      }
      return this.ws;
    };

    Neuron.prototype.parse_neuron = function(x, i) {
      var c, cs, d, error, network, q, sum, w, _i, _ref;
      if (this.ws === null) {
        this.ws = (function() {
          var _i, _ref, _results;
          _results = [];
          for (q = _i = 0, _ref = x.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; q = 0 <= _ref ? ++_i : --_i) {
            _results.push(0);
          }
          return _results;
        })();
      }
      cs = (function() {
        var _i, _ref, _results;
        _results = [];
        for (q = _i = 0, _ref = this.ws.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; q = 0 <= _ref ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      }).call(this);
      sum = 0;
      for (c = _i = 0, _ref = cs.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; c = 0 <= _ref ? ++_i : --_i) {
        sum = sum + x[c] * this.ws[c];
      }
      network = 1 / (1 + Math.pow(Math.E, sum * -1));
      error = this.zs[i] - network;
      d = error * this.learning_rate;
      this.ws = (function() {
        var _j, _ref1, _results;
        _results = [];
        for (w = _j = 0, _ref1 = this.ws.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; w = 0 <= _ref1 ? ++_j : --_j) {
          _results.push(this.ws[w] = Math.round((this.ws[w] + x[w] * d) * 10000) / 10000);
        }
        return _results;
      }).call(this);
      this.generation = this.generation + 1;
      return network;
    };

    Neuron.prototype.solve = function() {
      var cache, state, tmp, w;
      state = true;
      cache = new Array;
      while (state) {
        if (this.generation === 0) {
          cache.push(this.next_generation(false));
        } else {
          tmp = this.next_generation(false);
          state = !(cache.pop().toString() === tmp.toString());
          if (!state) {
            this.ws = (function() {
              var _i, _len, _ref, _results;
              _ref = this.ws;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                w = _ref[_i];
                _results.push(Math.round(w * 1) / 1);
              }
              return _results;
            }).call(this);
            tmp = this.ws;
          }
          cache.push(tmp);
        }
      }
      return cache[0];
    };

    return Neuron;

  })();

  and_neuron = new Neuron([0, 0, 0, 1]);

  or_neuron = new Neuron([0, 1, 1, 1]);

  xor_neuron = new Neuron([0, 1, 1, 0]);

  xnor_neuron = new Neuron([1, 0, 0, 1]);

  xor_neuron.load_vector([[0, 0], [0, 1], [1, 0], [1, 1]]);

  xor_neuron.load_neurons([and_neuron, or_neuron]);

  xor_neuron.solve();

  xor_neuron.next_generation(true);

  xnor_neuron.load_vector([[0, 0], [0, 1], [1, 0], [1, 1]]);

  xnor_neuron.load_neurons([and_neuron, or_neuron]);

  xnor_neuron.solve();

  xnor_neuron.next_generation(true);

}).call(this);
